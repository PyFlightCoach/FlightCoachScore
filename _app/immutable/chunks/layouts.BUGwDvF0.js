var v=Object.defineProperty;var d=(n,t,e)=>t in n?v(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var g=(n,t,e)=>d(n,typeof t!="symbol"?t+"":t,e);import{j as _,P as c}from"./analysis.DdsEFb_0.js";import"./api.CpnLB2Sq.js";var y=function(){function n(t,e){for(var r=0;r<e.length;r++){var s=e[r];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(t,s.key,s)}}return function(t,e,r){return e&&n(t.prototype,e),r&&n(t,r),t}}();function b(n,t){if(!(n instanceof t))throw new TypeError("Cannot call a class as a function")}var w=function(){function n(t,e){b(this,n),this._reset(),this.fileContents=t,this.defaultModelName=e||"untitled"}return y(n,[{key:"_reset",value:function(){this.result={models:[],materialLibraries:[]},this.currentMaterial="",this.currentGroup="",this.smoothingGroup=0}},{key:"parse",value:function(){this._reset();for(var e=function(l){var u=l.indexOf("#");return u>-1?l.substring(0,u):l},r=this.fileContents.split(`
`),s=0;s<r.length;s+=1){var a=e(r[s]),o=a.replace(/\s+/g," ").trim().split(" ");switch(o[0].toLowerCase()){case"o":this._parseObject(o);break;case"g":this._parseGroup(o);break;case"v":this._parseVertexCoords(o);break;case"vt":this._parseTextureCoords(o);break;case"vn":this._parseVertexNormal(o);break;case"l":this._parseLine(o);break;case"s":this._parseSmoothShadingStatement(o);break;case"f":this._parsePolygon(o);break;case"mtllib":this._parseMtlLib(o);break;case"usemtl":this._parseUseMtl(o);break}}return this.result}},{key:"_createNewModel",value:function(){var e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.defaultModelName;return{name:e,vertices:[],textureCoords:[],vertexNormals:[],faces:[],lines:[]}}},{key:"_currentModel",value:function(){if(this.result.models.length==0){var e=this._createNewModel();this.result.models.push(e),this.currentGroup="",this.smoothingGroup=0}return this.result.models[this.result.models.length-1]}},{key:"_parseObject",value:function(e){var r=e.length>=2?e[1]:this.defaultModelName,s=this._createNewModel(r);this.result.models.push(s),this.currentGroup="",this.smoothingGroup=0}},{key:"_parseGroup",value:function(e){if(e.length!=2)throw"Group statements must have exactly 1 argument (eg. g group_1)";this.currentGroup=e[1]}},{key:"_parseVertexCoords",value:function(e){var r=e.length>=2?parseFloat(e[1]):0,s=e.length>=3?parseFloat(e[2]):0,a=e.length>=4?parseFloat(e[3]):0;this._currentModel().vertices.push({x:r,y:s,z:a})}},{key:"_parseTextureCoords",value:function(e){var r=e.length>=2?parseFloat(e[1]):0,s=e.length>=3?parseFloat(e[2]):0,a=e.length>=4?parseFloat(e[3]):0;this._currentModel().textureCoords.push({u:r,v:s,w:a})}},{key:"_parseVertexNormal",value:function(e){var r=e.length>=2?parseFloat(e[1]):0,s=e.length>=3?parseFloat(e[2]):0,a=e.length>=4?parseFloat(e[3]):0;this._currentModel().vertexNormals.push({x:r,y:s,z:a})}},{key:"_parseLine",value:function(e){var r=e.length-1;if(r<2)throw"Line statement has less than 2 vertices"+this.filePath+this.lineNumber;for(var s=[],a=0;a<r;a+=1){var o=e[a+1],h=o.split("/");if(h.length<1||h.length>2)throw"Too many values (separated by /) for a single vertex"+this.filePath+this.lineNumber;var l=0,u=0;l=parseInt(h[0]),h.length>1&&h[1]!=""&&(u=parseInt(h[1])),s.push({vertexIndex:l,textureCoordsIndex:u})}this._currentModel().lines.push(s)}},{key:"_parsePolygon",value:function(e){var r=e.length-1;if(r<3)throw"Face statement has less than 3 vertices"+this.filePath+this.lineNumber;for(var s={material:this.currentMaterial,group:this.currentGroup,smoothingGroup:this.smoothingGroup,vertices:[]},a=0;a<r;a+=1){var o=e[a+1],h=o.split("/");if(h.length<1||h.length>3)throw"Too many values (separated by /) for a single vertex"+this.filePath+this.lineNumber;var l=0,u=0,i=0;if(l=parseInt(h[0]),h.length>1&&h[1]!=""&&(u=parseInt(h[1])),h.length>2&&(i=parseInt(h[2])),l==0)throw"Faces uses invalid vertex index of 0";l<0&&(l=this._currentModel().vertices.length+1+l),s.vertices.push({vertexIndex:l,textureCoordsIndex:u,vertexNormalIndex:i})}this._currentModel().faces.push(s)}},{key:"_parseMtlLib",value:function(e){e.length>=2&&this.result.materialLibraries.push(e[1])}},{key:"_parseUseMtl",value:function(e){e.length>=2&&(this.currentMaterial=e[1])}},{key:"_parseSmoothShadingStatement",value:function(e){if(e.length!=2)throw"Smoothing group statements must have exactly 1 argument (eg. s <number|off>)";var r=e[1].toLowerCase()=="off"?0:parseInt(e[1]);this.smoothingGroup=r}}]),n}(),k=w;const x=_(k),M=(n,t,e={},r={})=>{const s=t/2;let a=[];Object.keys(e).forEach(i=>{r[i]=[]});for(let i=0;i<n.data.length;i++)a.push(n.data[i].body_to_world(new c(0,s,0))),a.push(n.data[i].body_to_world(new c(0,-s,0)));let o=[],h=[],l=[];for(let i=0;i<a.length-2;i+=2)o.push(i),h.push(i+1),l.push(i+2),o.push(i+1),h.push(i+3),l.push(i+2),Object.entries(e).forEach(([f,m])=>{r[f].push(m[i]),r[f].push(m[i]),r[f].push(m[i]),r[f].push(m[i])});let u={x:[],y:[],z:[]};return a.forEach(i=>{u.x.push(i.x),u.y.push(i.y),u.z.push(i.z)}),{...u,i:o,j:h,k:l,type:"mesh3d",...r}},C=(n,t)=>Object.keys(n).map(e=>({...M(n[e],t),name:e})),j=(n,t=null)=>{let e=[];for(let r=0;r<n.length;r++)e.push({type:"scatter3d",x:[n[r].x],y:[n[r].y],z:[n[r].z],mode:"markers",marker:{color:"black",size:3},showlegend:!1,text:t==null?"":t[r]});return e};class p{constructor(t,e,r){g(this,"vertices");g(this,"faces");g(this,"normals");this.vertices=t,this.faces=e,this.normals=r}static parse_dict(t){return new p(t.vertices.map(e=>new c(e.x,e.y,e.z)),t.faces,t.normals.map(e=>new c(e.x,e.y,e.z)))}static from_objfile(t){const e=new x(t).parse(),r=e.models[0].vertices.map(o=>new c(o.x,o.y,o.z)),s=e.models[0].faces.map(o=>[o.vertices[0].vertexIndex,o.vertices[1].vertexIndex,o.vertices[2].vertexIndex]),a=e.models[0].vertexNormals.map(o=>new c(o.x,o.y,o.z));return new p(r,s,a)}static parse(t,e=null,r=null){const s=t.split(`
`);let a=[];const o=[];let h=[];return s.forEach(l=>{const u=l.split(" ");u[0]=="v"?a.push(new c(parseFloat(u[1]),parseFloat(u[2]),parseFloat(u[3]))):u[0]=="f"?o.push(u.slice(1).map(i=>parseInt(i)-1)):u[0]=="vn"&&h.push(new c(parseFloat(u[1]),parseFloat(u[2]),parseFloat(u[3])))}),r!=null&&(a=a.map(l=>r.transform_point(l)),h.forEach(l=>r.transform_point(l))),e!=null&&(a=a.map(l=>l.offset(e))),new p(a,o,h)}scale(t){return new p(this.vertices.map(e=>e.mul(t)),this.faces,this.normals)}to_mesh3d(t,e,r={}){const s=this.vertices.map(a=>t.offset(e.transform_point(a)));return{x:s.map(a=>a.x),y:s.map(a=>a.y),z:s.map(a=>a.z),i:this.faces.map(a=>a[0]),j:this.faces.map(a=>a[1]),k:this.faces.map(a=>a[2]),type:"mesh3d",showscale:!1,...r,lighting:{ambient:.5,diffuse:1,fresnel:.2,specular:.1,roughness:.1,facenormalsepsilon:1e-6,vertexnormalsepsilon:1e-12},lightposition:{x:100,y:0,z:1e3}}}}const G=(n,t,e={})=>n.data.map(r=>t.to_mesh3d(r.pos,r.att,e)),L={legend:{font:{size:20},yanchor:"top",y:.99,xanchor:"left",x:.01},margin:{l:0,r:0,t:0,b:0},scene:{aspectmode:"data",camera:{up:{x:0,y:0,z:1},center:{x:0,y:0,z:0},eye:{x:0,y:-2,z:-1},projection:{type:"perspective"}}}};export{p as O,C as c,L as l,G as m,j as p,M as r};
